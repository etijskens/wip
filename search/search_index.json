{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The wiptools package Python project skeleton and management Table of Contents Overview Installation User guide API reference","title":"Home"},{"location":"#the-wiptools-package","text":"Python project skeleton and management","title":"The wiptools package"},{"location":"#table-of-contents","text":"Overview Installation User guide API reference","title":"Table of Contents"},{"location":"api-reference/","text":"Wiptools API reference wip Command line interface wip. Usage: wip [OPTIONS] COMMAND [ARGS]... Options: -v, --verbosity The verbosity of the program output. --version Print the wiptools version number. --help Show this message and exit. add Add components, such as submodules and CLIs, to the project. Args: name: For submodules the name can contain a path to an already existion component relative to the package directory. CLI names must not contain a path, only a name. Usage: wip add [OPTIONS] NAME Options: --py Add a Python submodule to the project. --cli Add a Python CLI (with a single command) to the project. --clisub Add a Python CLI with subcommands to the project. --cpp Add a C++ binary extension module to the project (building requires nanobind and CMake). --f90 Add a Modern Fortran binary extension module to the project (building requires numpy.f2py and CMake). --help Show this message and exit. build Build binary extension modules. Args: component: Path to the component to build, relative to package directory. Usage: wip build [OPTIONS] [COMPONENT] Options: --cpp Build all C++ binary extension modules. --f90 Build all Modern Fortran binary extension modules. --help Show this message and exit. bump Bump2version wrapper. Args: args: a quoted str containing the bump2version arguments. Usage: wip bump [OPTIONS] [ARGS] Options: --help Show this message and exit. docs Add documentation to the project. Usage: wip docs [OPTIONS] Options: -f, --fmt [md|rst|] Documentation format to be used (md=Markdown (default), rst=restructuredText). --help Show this message and exit. env Check the environment for needed components. Usage: wip env [OPTIONS] Options: --help Show this message and exit. info List info about the project's structure. Usage: wip info [OPTIONS] Options: -p, --pkg Lists the package tree, with information about submodules and CLIs. -d, --dev Lists the developer info. -e, --env Run environment check. --help Show this message and exit. init Initialize a new project skeleton. Args: project_name: name of the project folder to create. Usage: wip init [OPTIONS] PROJECT_NAME Options: --python-version TEXT The minimal Python version for the project. -d, --description TEXT A short (1 line) description of the project. --remote TEXT Create a remote GitHub repo with visibility 'public' (default) or 'private'. If 'none' is specified no remote is created. This option is case- insensitive.The creation of a remote GitHub repo requires a GitHub username and a personal access token with `repo` and `read:org` permissions. -f, --fmt [md|rst|] Documentation format to be used (md=Markdown, rst=restructuredText). --config PATH The location (path) of the config.file with developer information (name, e-mail address, GitHub username). If the file does not exist, it is created and the user is prompted to supply the fields. If the file exists, but has missing information, the user is prompted to supply the missing fields, but the file is NOT updated. --help Show this message and exit. init-remote Add a remote GitHub repo. Usage: wip init-remote [OPTIONS] Options: --private Add a private remote GitHub repo, otherwise a public one. --help Show this message and exit. Python package wiptools Common tools between the CLIs","title":"Wiptools API reference"},{"location":"api-reference/#wiptools-api-reference","text":"","title":"Wiptools API reference"},{"location":"api-reference/#wip","text":"Command line interface wip. Usage: wip [OPTIONS] COMMAND [ARGS]... Options: -v, --verbosity The verbosity of the program output. --version Print the wiptools version number. --help Show this message and exit.","title":"wip"},{"location":"api-reference/#add","text":"Add components, such as submodules and CLIs, to the project. Args: name: For submodules the name can contain a path to an already existion component relative to the package directory. CLI names must not contain a path, only a name. Usage: wip add [OPTIONS] NAME Options: --py Add a Python submodule to the project. --cli Add a Python CLI (with a single command) to the project. --clisub Add a Python CLI with subcommands to the project. --cpp Add a C++ binary extension module to the project (building requires nanobind and CMake). --f90 Add a Modern Fortran binary extension module to the project (building requires numpy.f2py and CMake). --help Show this message and exit.","title":"add"},{"location":"api-reference/#build","text":"Build binary extension modules. Args: component: Path to the component to build, relative to package directory. Usage: wip build [OPTIONS] [COMPONENT] Options: --cpp Build all C++ binary extension modules. --f90 Build all Modern Fortran binary extension modules. --help Show this message and exit.","title":"build"},{"location":"api-reference/#bump","text":"Bump2version wrapper. Args: args: a quoted str containing the bump2version arguments. Usage: wip bump [OPTIONS] [ARGS] Options: --help Show this message and exit.","title":"bump"},{"location":"api-reference/#docs","text":"Add documentation to the project. Usage: wip docs [OPTIONS] Options: -f, --fmt [md|rst|] Documentation format to be used (md=Markdown (default), rst=restructuredText). --help Show this message and exit.","title":"docs"},{"location":"api-reference/#env","text":"Check the environment for needed components. Usage: wip env [OPTIONS] Options: --help Show this message and exit.","title":"env"},{"location":"api-reference/#info","text":"List info about the project's structure. Usage: wip info [OPTIONS] Options: -p, --pkg Lists the package tree, with information about submodules and CLIs. -d, --dev Lists the developer info. -e, --env Run environment check. --help Show this message and exit.","title":"info"},{"location":"api-reference/#init","text":"Initialize a new project skeleton. Args: project_name: name of the project folder to create. Usage: wip init [OPTIONS] PROJECT_NAME Options: --python-version TEXT The minimal Python version for the project. -d, --description TEXT A short (1 line) description of the project. --remote TEXT Create a remote GitHub repo with visibility 'public' (default) or 'private'. If 'none' is specified no remote is created. This option is case- insensitive.The creation of a remote GitHub repo requires a GitHub username and a personal access token with `repo` and `read:org` permissions. -f, --fmt [md|rst|] Documentation format to be used (md=Markdown, rst=restructuredText). --config PATH The location (path) of the config.file with developer information (name, e-mail address, GitHub username). If the file does not exist, it is created and the user is prompted to supply the fields. If the file exists, but has missing information, the user is prompted to supply the missing fields, but the file is NOT updated. --help Show this message and exit.","title":"init"},{"location":"api-reference/#init-remote","text":"Add a remote GitHub repo. Usage: wip init-remote [OPTIONS] Options: --private Add a private remote GitHub repo, otherwise a public one. --help Show this message and exit.","title":"init-remote"},{"location":"api-reference/#wiptools--python-package-wiptools","text":"Common tools between the CLIs","title":"Python package wiptools"},{"location":"installation/","text":"Installation Prerequisites In order to make full use of wiptools, it is higly recommended to first create a github account for storing your work with git version controlled. If you do not already have a GitHub account, create one at Signing up for a new GitHub account , and create a (classic) personal access token following these instructions . This is a kind of password for accessing your github repositories. When creating a GitHub personal access token for use with wiptools, make sure that you check the scopes repo and read:org . Installing on a workstation Wiptools is published on PyPI , and hence it can be installed with its dependencies as: > pip install wiptools This installs the bare wip . Because wip relies on quite a bit of other tools, installing al its dependencies may waste quite a bit of resources, especially on clusters. For that reason the user is responsible for installing them - if needed. The wip env command lists which tools are available in the current environment and which not, what they are used for and how they can be installed. Here is the output from wip env if all components are missing. > wip env For a full functional `wip` the following commands and packages must be available in your environment: Python: v3.10.4 (OK) Command git is missing in the current environment (minimal=v2.35). To install see https://git-scm.com/book/en/v2/Getting-Started-Installing-Git. Needed for local and remote version control. Highly recommended. Command gh is missing in the current environment (minimal=v2.31). To install see https://cli.github.com/manual/installation. Enables `wip init` to create remote GitHub repositories. Highly recommended. Command bump2version is missing in the current environment (minimal=v1.0). To install: `python -m pip install bump2version --upgrade [--user]` Needed for version string management. Highly recommended. Command poetry is missing in the current environment (minimal=v1.5). To install: `python -m pip install poetry --upgrade [--user]` Needed for dependency management, publishing to PyPI. Highly recommended in development environments. Command mkdocs is missing in the current environment (minimal=v1.4.3). To install: `python -m pip install mkdocs --upgrade [--user]` Needed for documentation generation. Highly recommended on workstations, discouraged on HPC clusters. Module numpy is missing in the current environment (minimal=v1.4). To install: `python -m pip install nanobind --upgrade [--user]` Needed to construct C++ binary extension modules. Module numpy is missing in the current environment (minimal=v1.22). To install: `python -m pip install numpy --upgrade [--user]` Needed to construct Modern Fortran binary extension modules (f2py is part of numpy). Generally extremely useful for scientific computing, HPC, ... Command cmake is missing in the current environment (minimal=v3.18). To install see https://cmake.org/install/. Needed to build C++ and Modern Fortran binary extension modules. Some components are missing. This is only a problem is you are planning to use them. If you are working on your own machine, you must install these components yourself. If you are working on a HPC cluster, preferably load the corresponding LMOD modules. Installing on a HPC cluster (Linux) On a HPC cluster software is installed in a central location, where users do not have write access. Users can, however, pip install additional Python packages by adding the --user flag. This installs the package by default under ~/.local . E.g. > python --version Python 3.10.4 > pip install --user wiptools ... will install wiptools in ~/.local/lib/python3.10/site-packages . On VSC clusters, however, the home directory is in the $VSC_HOME file system, which is rather small (<10GB) and therefor not suited for local installations. It is therefor recommended change the default --user installation location by setting the PYTHONUSERBASE environment variable. If you are on a VSC cluster, e.g. Vaughan, $VSC_DATA is the prefered file system for this. Therfor, add the following lines to your .bashrc file: export PYTHONUSERBASE=$VSC_DATA/.local/ export PATH=\"$PATH:$PYTHONUSERBASE/bin/\" The first line ensures that > pip install --user wiptools will install wiptools in $VSC_DATA/.local/lib/python3.10/site-packages (when using Python 3.10, as above). The second line ensures that, if the package installs some CLIs, your shell will be able to find them. Wiptools indeed comes with a CLI wip : > echo $VSC_DATA /data/antwerpen/201/vsc20170 > echo $PYTHONUSERBASE /data/antwerpen/201/vsc20170/.local > which wip /data/antwerpen/201/vsc20170/.local/bin/wip As an alternative to using pip's --user flag, you can install wiptools in a virtual environment. To learn about Python virtual environments, checkout this .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#prerequisites","text":"In order to make full use of wiptools, it is higly recommended to first create a github account for storing your work with git version controlled. If you do not already have a GitHub account, create one at Signing up for a new GitHub account , and create a (classic) personal access token following these instructions . This is a kind of password for accessing your github repositories. When creating a GitHub personal access token for use with wiptools, make sure that you check the scopes repo and read:org .","title":"Prerequisites"},{"location":"installation/#installing-on-a-workstation","text":"Wiptools is published on PyPI , and hence it can be installed with its dependencies as: > pip install wiptools This installs the bare wip . Because wip relies on quite a bit of other tools, installing al its dependencies may waste quite a bit of resources, especially on clusters. For that reason the user is responsible for installing them - if needed. The wip env command lists which tools are available in the current environment and which not, what they are used for and how they can be installed. Here is the output from wip env if all components are missing. > wip env For a full functional `wip` the following commands and packages must be available in your environment: Python: v3.10.4 (OK) Command git is missing in the current environment (minimal=v2.35). To install see https://git-scm.com/book/en/v2/Getting-Started-Installing-Git. Needed for local and remote version control. Highly recommended. Command gh is missing in the current environment (minimal=v2.31). To install see https://cli.github.com/manual/installation. Enables `wip init` to create remote GitHub repositories. Highly recommended. Command bump2version is missing in the current environment (minimal=v1.0). To install: `python -m pip install bump2version --upgrade [--user]` Needed for version string management. Highly recommended. Command poetry is missing in the current environment (minimal=v1.5). To install: `python -m pip install poetry --upgrade [--user]` Needed for dependency management, publishing to PyPI. Highly recommended in development environments. Command mkdocs is missing in the current environment (minimal=v1.4.3). To install: `python -m pip install mkdocs --upgrade [--user]` Needed for documentation generation. Highly recommended on workstations, discouraged on HPC clusters. Module numpy is missing in the current environment (minimal=v1.4). To install: `python -m pip install nanobind --upgrade [--user]` Needed to construct C++ binary extension modules. Module numpy is missing in the current environment (minimal=v1.22). To install: `python -m pip install numpy --upgrade [--user]` Needed to construct Modern Fortran binary extension modules (f2py is part of numpy). Generally extremely useful for scientific computing, HPC, ... Command cmake is missing in the current environment (minimal=v3.18). To install see https://cmake.org/install/. Needed to build C++ and Modern Fortran binary extension modules. Some components are missing. This is only a problem is you are planning to use them. If you are working on your own machine, you must install these components yourself. If you are working on a HPC cluster, preferably load the corresponding LMOD modules.","title":"Installing on a workstation"},{"location":"installation/#installing-on-a-hpc-cluster-linux","text":"On a HPC cluster software is installed in a central location, where users do not have write access. Users can, however, pip install additional Python packages by adding the --user flag. This installs the package by default under ~/.local . E.g. > python --version Python 3.10.4 > pip install --user wiptools ... will install wiptools in ~/.local/lib/python3.10/site-packages . On VSC clusters, however, the home directory is in the $VSC_HOME file system, which is rather small (<10GB) and therefor not suited for local installations. It is therefor recommended change the default --user installation location by setting the PYTHONUSERBASE environment variable. If you are on a VSC cluster, e.g. Vaughan, $VSC_DATA is the prefered file system for this. Therfor, add the following lines to your .bashrc file: export PYTHONUSERBASE=$VSC_DATA/.local/ export PATH=\"$PATH:$PYTHONUSERBASE/bin/\" The first line ensures that > pip install --user wiptools will install wiptools in $VSC_DATA/.local/lib/python3.10/site-packages (when using Python 3.10, as above). The second line ensures that, if the package installs some CLIs, your shell will be able to find them. Wiptools indeed comes with a CLI wip : > echo $VSC_DATA /data/antwerpen/201/vsc20170 > echo $PYTHONUSERBASE /data/antwerpen/201/vsc20170/.local > which wip /data/antwerpen/201/vsc20170/.local/bin/wip As an alternative to using pip's --user flag, you can install wiptools in a virtual environment. To learn about Python virtual environments, checkout this .","title":"Installing on a HPC cluster (Linux)"},{"location":"overview/","text":"About Wiptools is a collection of tools for setting up a Python project skeleton and managing it. I wrote Wiptools (and its predecessors micc and micc2 ) because with every new Python project I found myself loosing time looking up and fixing the nitty-gritty details for setting up a remote GitHub repo, creating C++ binary extension modules or a CLI with subcommands, setting up documentation, and many more. If you start new projects on a regular basis using the same project skeleton and tools every time significantly improves productivity. It also turned out very useful for the Parallel Programming course , especially the ability to easily prototype and test in Python and provide performant C++ or Fortran as replacement modules. Wiptools provides: a project skeleton automatic creation of a git repository (locally, as well as remotely on github.com) integration with poetry for dependency management and virtual environments, publishing on PyPI version management with bump2version adding subcomponents Python (sub)modules binary extension modules in C++ with nanobind ) and Fortran with f2py command line interfaces with click , single command and with subcommands test templates for all added components and pytest integration documentation generation with mkdocs or sphinx (to be implemented) Links Wiptools GitHub repository Wiptools homepage","title":"About"},{"location":"overview/#about","text":"Wiptools is a collection of tools for setting up a Python project skeleton and managing it. I wrote Wiptools (and its predecessors micc and micc2 ) because with every new Python project I found myself loosing time looking up and fixing the nitty-gritty details for setting up a remote GitHub repo, creating C++ binary extension modules or a CLI with subcommands, setting up documentation, and many more. If you start new projects on a regular basis using the same project skeleton and tools every time significantly improves productivity. It also turned out very useful for the Parallel Programming course , especially the ability to easily prototype and test in Python and provide performant C++ or Fortran as replacement modules. Wiptools provides: a project skeleton automatic creation of a git repository (locally, as well as remotely on github.com) integration with poetry for dependency management and virtual environments, publishing on PyPI version management with bump2version adding subcomponents Python (sub)modules binary extension modules in C++ with nanobind ) and Fortran with f2py command line interfaces with click , single command and with subcommands test templates for all added components and pytest integration documentation generation with mkdocs or sphinx (to be implemented)","title":"About"},{"location":"overview/#links","text":"Wiptools GitHub repository Wiptools homepage","title":"Links"},{"location":"user-guide/","text":"User guide The work horse of wiptools is the wip CLI. You can ask wip for help: > wip --help Usage: wip [OPTIONS] COMMAND [ARGS]... Command line interface wip. ... as well as its subcommands: > wip info --help Usage: wip info [OPTIONS] List info about the project's structure. ... Wip relies on a bunch of other tools. You can test your environment for their presence and version compliance with wip env : > wip env For full `wip` functionality the following commands and packages must be available in our envirionment: python 3.9.5 (default, Sep 20 2021, 16:33:56) [Clang 12.0.5 (clang-1205.0.22.9)] (OK) git version 2.35.1 (OK) gh version 2.31.0 (2023-06-20) https://github.com/cli/cli/releases/tag/v2.31.0 (OK) bumpversion: v1.0.1 (using Python v3.9.5) (OK) nanobind 1.4.0 (OK) numpy 1.25.0 : minimal='2.22' (not OK) cmake version 3.21.2 (OK) Poetry (version 1.5.1) (OK) mkdocs, version 1.4.3 from /Users/etijskens/software/dev/workspace/wiptools/.venv/lib/python3.9/site-packages/mkdocs (Python 3.9) (OK) Create a new project skeleton You create a new project skeleton by executing wip init <project_name> . This will create a project folder project_name in the current working directory. Before wip can create a new project skeleton, some developer specific and project specific information must be provided. Developer info - GitHub access Tip Checkout Prerequisites before using wip . As the developer info is typically the same for many projects, it is stored in a config.json file. It contains your name , your e-mail address , and your GitHub username . Here is an example config.json file: { \"full_name\": \"Bert Tijskens\", \"email_address\": \"engelbert.tijskens@uantwerpen.be\", \"github_username\": \"etijskens\" } The default location of the config.json file is $HOME/.wiptools , but you can store it wherever you like, or with a different name, in case you need to deal with several sets of developer info, e.g. if you have work-related as well as personal projects, which are maintained on different GitHub accounts or with a different e-mail address. In that case use the --config flag to pass a config file other than the default one: > wip init <project_name> --config=path/to/another_config.json [options] If the config file does not exist, which is typically the case the first time you execute wip init , wip prompts you to supply your name, your e-mail address and your GitHub username, and creates a new file to store the supplied info. If, on the other hand, the file exists, but has missing fields, the user is also prompted to supply them, but the file is not updated. When a new GitHub username is supplied, wip also prompts the user to supply a GitHub personal access token . This is a kind of password for accessing your GitHub account. It enables wip to automatically create a remote GitHub repository to store and backup you work. The personal access tokens you provide are always copied to $HOME/.wiptools/github_{github_username}.pat , where github_username is taken from the corresponding field in the config.json file. When you create a new project wip automatically creates a remote GitHub repository for the project. This is highly recommended, as this gets you a secure backup of your code (and all its prior versions) on a remote machine. The only effort needed is that you commit and push your code regularly to the remote repo. Note If you do not already have a GitHub account, create one at Signing up for a new GitHub account and create a (classic) personal access token following these instructions . When creating a GitHub personal access token for use with wip, make sure that you check the scopes repo and read:org . Note Wip will automatically create a local git repository and a remote public GitHub repo for you project (if you have provided a GitHub username and a personal access token (see Developer info ). Use --remote=private|none to create a private GitHub repo, or no remote repo at all. Project info For every project you create, wip will ask you to supply a brief project description, which can be left empty, and a minimal Python version. Note After creating the project skeleton, you must cd into your project folder to apply other wip commands. Note If you choose to not create a remote GitHub repo (e.g. because you have no internet connection), you can always add it later with wip init_remote [--private] . ) Listing project info Cd into the project folder ( cd foo ) and use wip info : path/to > wip init FOO ... path/to > cd FOO path/to/FOO > wip info --pkg --dev Project : FOO: <project_short_description> Version : 0.0.0 Package : foo GitHub repo: -- Home page : -- Location : /Users/etijskens/software/dev/workspace/.test-wip/FOO docs format: none Developer info: author : Bert Tijskens e-mail : engelbert.tijskens@uantwerpen.be GitHub username: etijskens Structure of Python package foo foo [Python module] \u2514\u2500\u2500 __init__.py Note that wip translates the project name FOO in to the PEP compliant package name foo , converting to lowercase (and replacing hyphens with underscores). Add components You can add Python submodules ( --py ), C++ binary extension modules ( --cpp ) or Modern Fortran binary extension modules ( --f90 ), as well as CLIs with a single command ( --cli ) or with subcommands( --clisub ): path/to/FOO > wip add foo_py --py path/to/FOO > wip add foo_cpp --cpp path/to/FOO > wip add foo_f90 --f90 path/to/FOO > wip add foo_cli --cli path/to/FOO > wip add foo_clisub --clisub path/to/FOO > wip info --pkg Project : FOO: the foo package Version : 0.0.0 Package : foo GitHub repo: https://github.com/<your github username>/foo Home page : https://<your github username>.github.io/foo Location : /Users/etijskens/software/dev/workspace/wiptools/.test-workspace/foofoo docs format: none Structure of Python package foofoo foo [Python module] \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 foo_cli [CLI] \u2502 \u2514\u2500\u2500 __main__.py \u251c\u2500\u2500 foo_clisub [CLI] \u2502 \u2514\u2500\u2500 __main__.py \u251c\u2500\u2500 foo_cpp [C++ binary extension module] \u2502 \u251c\u2500\u2500 foo_cpp.cpp \u2502 \u2514\u2500\u2500 foo_cpp.md \u251c\u2500\u2500 foo_f90 [Modern Fortran binary extension module] \u2502 \u251c\u2500\u2500 foo_f90.f90 \u2502 \u2514\u2500\u2500 foo_f90.md \u2514\u2500\u2500 foo_py [Python module] \u2514\u2500\u2500 __init__.py Python submodules can contain other Python submodules, as well as binary extension modules. You only need to preceed the module name with the path (relative to the package folder), e.g. to add a C++ binary extension module to the foo_py submodule: path/to/FOO > wip add foo_py/bar --cpp ... path/to/FOO > wip info ... Structure of Python package foo foo [Python module] \u251c\u2500\u2500 __init__.py ... \u2514\u2500\u2500 foo_py [Python module] \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 bar [C++ binary extension module] \u251c\u2500\u2500 bar.cpp \u2514\u2500\u2500 bar.md To build the binary extension modules use the wip build command. This builds all binary extension modules and installs them in the parent of the submodule folder. Hence, they can be imported using the path you specified when you added it. E.g. a client script could import these modules as: import foo # the foo package import foo.foo_cpp # the foo_cpp submodule (C++ binary extension) import foo.foo_f90 # the foo_f90 submodule (Fortran binary extension) import foo.foo_py # the foo_py submodule import foo.foo_py.bar # the bar subsubmodule in the foo_py submodule I the build process was successful, will see some dynamic libraries in the directory tree. On Linux and MacOS these have the .so (shared objecrt) extension and .dll On Windows. The middle part depends on the Python distribution the binary extension was built against, and on the operating system. Structure of Python package foo foo [Python module] \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 foo_cli [CLI] \u2502 \u2514\u2500\u2500 __main__.py \u251c\u2500\u2500 foo_clisub [CLI] \u2502 \u2514\u2500\u2500 __main__.py \u251c\u2500\u2500 foo_cpp.cpython-39.darwin.so \u251c\u2500\u2500 foo_cpp [C++ binary extension module] \u2502 \u251c\u2500\u2500 foo_cpp.cpp \u2502 \u2514\u2500\u2500 foo_cpp.md \u251c\u2500\u2500 foo_f90.cpython-39.darwin.so \u251c\u2500\u2500 foo_f90 [Modern Fortran binary extension module] \u2502 \u251c\u2500\u2500 foo_f90.f90 \u2502 \u2514\u2500\u2500 foo_f90.md \u2514\u2500\u2500 foo_py [Python module] \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 bar.cpython-39.darwin.so \u2514\u2500\u2500 bar [C++ binary extension module] \u251c\u2500\u2500 bar.cpp \u2514\u2500\u2500 bar.md You can build a single binary extension by specifiyng its path: path/to/FOO > wip build foo_py/bar or build all C++/Fortran binary extensions using wip build --cpp|--f90 . Documentation For small projects, we recommend writing down the documentation in README.md . Larger projects with submodules or CLIs are more conveniently documented with mkdocs , using the Markdown format, or sphinx using the restructuredText . When creating a new project, wip asks for a documentation format. If you choose none, you can always add the necessary documentation templates running wip docs [--md|--rst] . Tip Learn documenting your project with mkdocs [here] (https://realpython.com/python-project-documentation-with-mkdocs/). Version management Wip relies on bump2version for version management. Newly created project have a bumpversion.cfg file. The bumpversion command can directly be used, e.g.: bump[2]version major|minor|patch|release . There is also a wip subcommand wip bump that wraps the bumpversion command and lists information about the previous and the new version: path/to/FOO > bumpversion patch path/to/FOO > wip bump patch [[Running `bump2version patch`` in directory 'foo' ... ]] (done Running `bump2version patch`) foo v0.0.1-dev -> v0.0.2-dev path/to/FOO > wip bump release [[Running `bump2version release`` in directory 'foo' ... ]] (done Running `bump2version release`) foo v0.0.2-dev -> v0.0.2 > wip bump minor [[Running `bump2version minor`` in directory 'foo' ... ]] (done Running `bump2version minor`) foo v0.0.2 -> v0.1.0-dev Publishing on PyPI When your code is published on PyPI users can effortlessly install it with pip install your-package . Dependencies are automatically installed as well. Wip relies on poetry for publishing to PyPI . To be able to publish on PyPI, you must Create an account on PyPI . Log in on your account, and go to account settings . Scroll down and hit Add API token . Choose a token name, e.g. poetry-publishing-on-pypi , and select a scope, e.g. Entire account (all projects) to use the token for publishing all your projects. Hit Add token to generate a new token, and copy the token. Finally, add your API token to Poetry with this command poetry config pypi-token.pypi your-api-token (paste the copied token for your-api-token ). Now you can publish your code as below: (wiptools-py3.9) ~/workspace/wiptools > poetry publish --build Building wiptools (1.2.0-dev) - Building sdist - Built wiptools-1.2.0.dev0.tar.gz - Building wheel - Built wiptools-1.2.0.dev0-py3-none-any.whl Publishing wiptools (1.2.0-dev) to PyPI - Uploading wiptools-1.2.0.dev0-py3-none-any.whl 100% - Uploading wiptools-1.2.0.dev0.tar.gz 100% Note You can publish a version of your code only once to PyPI. If you want to publish an update, you must bump2version your code first.","title":"User guide"},{"location":"user-guide/#user-guide","text":"The work horse of wiptools is the wip CLI. You can ask wip for help: > wip --help Usage: wip [OPTIONS] COMMAND [ARGS]... Command line interface wip. ... as well as its subcommands: > wip info --help Usage: wip info [OPTIONS] List info about the project's structure. ... Wip relies on a bunch of other tools. You can test your environment for their presence and version compliance with wip env : > wip env For full `wip` functionality the following commands and packages must be available in our envirionment: python 3.9.5 (default, Sep 20 2021, 16:33:56) [Clang 12.0.5 (clang-1205.0.22.9)] (OK) git version 2.35.1 (OK) gh version 2.31.0 (2023-06-20) https://github.com/cli/cli/releases/tag/v2.31.0 (OK) bumpversion: v1.0.1 (using Python v3.9.5) (OK) nanobind 1.4.0 (OK) numpy 1.25.0 : minimal='2.22' (not OK) cmake version 3.21.2 (OK) Poetry (version 1.5.1) (OK) mkdocs, version 1.4.3 from /Users/etijskens/software/dev/workspace/wiptools/.venv/lib/python3.9/site-packages/mkdocs (Python 3.9) (OK)","title":"User guide"},{"location":"user-guide/#create-a-new-project-skeleton","text":"You create a new project skeleton by executing wip init <project_name> . This will create a project folder project_name in the current working directory. Before wip can create a new project skeleton, some developer specific and project specific information must be provided.","title":"Create a new project skeleton"},{"location":"user-guide/#developer-info-github-access","text":"Tip Checkout Prerequisites before using wip . As the developer info is typically the same for many projects, it is stored in a config.json file. It contains your name , your e-mail address , and your GitHub username . Here is an example config.json file: { \"full_name\": \"Bert Tijskens\", \"email_address\": \"engelbert.tijskens@uantwerpen.be\", \"github_username\": \"etijskens\" } The default location of the config.json file is $HOME/.wiptools , but you can store it wherever you like, or with a different name, in case you need to deal with several sets of developer info, e.g. if you have work-related as well as personal projects, which are maintained on different GitHub accounts or with a different e-mail address. In that case use the --config flag to pass a config file other than the default one: > wip init <project_name> --config=path/to/another_config.json [options] If the config file does not exist, which is typically the case the first time you execute wip init , wip prompts you to supply your name, your e-mail address and your GitHub username, and creates a new file to store the supplied info. If, on the other hand, the file exists, but has missing fields, the user is also prompted to supply them, but the file is not updated. When a new GitHub username is supplied, wip also prompts the user to supply a GitHub personal access token . This is a kind of password for accessing your GitHub account. It enables wip to automatically create a remote GitHub repository to store and backup you work. The personal access tokens you provide are always copied to $HOME/.wiptools/github_{github_username}.pat , where github_username is taken from the corresponding field in the config.json file. When you create a new project wip automatically creates a remote GitHub repository for the project. This is highly recommended, as this gets you a secure backup of your code (and all its prior versions) on a remote machine. The only effort needed is that you commit and push your code regularly to the remote repo. Note If you do not already have a GitHub account, create one at Signing up for a new GitHub account and create a (classic) personal access token following these instructions . When creating a GitHub personal access token for use with wip, make sure that you check the scopes repo and read:org . Note Wip will automatically create a local git repository and a remote public GitHub repo for you project (if you have provided a GitHub username and a personal access token (see Developer info ). Use --remote=private|none to create a private GitHub repo, or no remote repo at all.","title":"Developer info - GitHub access"},{"location":"user-guide/#project-info","text":"For every project you create, wip will ask you to supply a brief project description, which can be left empty, and a minimal Python version. Note After creating the project skeleton, you must cd into your project folder to apply other wip commands. Note If you choose to not create a remote GitHub repo (e.g. because you have no internet connection), you can always add it later with wip init_remote [--private] . )","title":"Project info"},{"location":"user-guide/#listing-project-info","text":"Cd into the project folder ( cd foo ) and use wip info : path/to > wip init FOO ... path/to > cd FOO path/to/FOO > wip info --pkg --dev Project : FOO: <project_short_description> Version : 0.0.0 Package : foo GitHub repo: -- Home page : -- Location : /Users/etijskens/software/dev/workspace/.test-wip/FOO docs format: none Developer info: author : Bert Tijskens e-mail : engelbert.tijskens@uantwerpen.be GitHub username: etijskens Structure of Python package foo foo [Python module] \u2514\u2500\u2500 __init__.py Note that wip translates the project name FOO in to the PEP compliant package name foo , converting to lowercase (and replacing hyphens with underscores).","title":"Listing project info"},{"location":"user-guide/#add-components","text":"You can add Python submodules ( --py ), C++ binary extension modules ( --cpp ) or Modern Fortran binary extension modules ( --f90 ), as well as CLIs with a single command ( --cli ) or with subcommands( --clisub ): path/to/FOO > wip add foo_py --py path/to/FOO > wip add foo_cpp --cpp path/to/FOO > wip add foo_f90 --f90 path/to/FOO > wip add foo_cli --cli path/to/FOO > wip add foo_clisub --clisub path/to/FOO > wip info --pkg Project : FOO: the foo package Version : 0.0.0 Package : foo GitHub repo: https://github.com/<your github username>/foo Home page : https://<your github username>.github.io/foo Location : /Users/etijskens/software/dev/workspace/wiptools/.test-workspace/foofoo docs format: none Structure of Python package foofoo foo [Python module] \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 foo_cli [CLI] \u2502 \u2514\u2500\u2500 __main__.py \u251c\u2500\u2500 foo_clisub [CLI] \u2502 \u2514\u2500\u2500 __main__.py \u251c\u2500\u2500 foo_cpp [C++ binary extension module] \u2502 \u251c\u2500\u2500 foo_cpp.cpp \u2502 \u2514\u2500\u2500 foo_cpp.md \u251c\u2500\u2500 foo_f90 [Modern Fortran binary extension module] \u2502 \u251c\u2500\u2500 foo_f90.f90 \u2502 \u2514\u2500\u2500 foo_f90.md \u2514\u2500\u2500 foo_py [Python module] \u2514\u2500\u2500 __init__.py Python submodules can contain other Python submodules, as well as binary extension modules. You only need to preceed the module name with the path (relative to the package folder), e.g. to add a C++ binary extension module to the foo_py submodule: path/to/FOO > wip add foo_py/bar --cpp ... path/to/FOO > wip info ... Structure of Python package foo foo [Python module] \u251c\u2500\u2500 __init__.py ... \u2514\u2500\u2500 foo_py [Python module] \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 bar [C++ binary extension module] \u251c\u2500\u2500 bar.cpp \u2514\u2500\u2500 bar.md To build the binary extension modules use the wip build command. This builds all binary extension modules and installs them in the parent of the submodule folder. Hence, they can be imported using the path you specified when you added it. E.g. a client script could import these modules as: import foo # the foo package import foo.foo_cpp # the foo_cpp submodule (C++ binary extension) import foo.foo_f90 # the foo_f90 submodule (Fortran binary extension) import foo.foo_py # the foo_py submodule import foo.foo_py.bar # the bar subsubmodule in the foo_py submodule I the build process was successful, will see some dynamic libraries in the directory tree. On Linux and MacOS these have the .so (shared objecrt) extension and .dll On Windows. The middle part depends on the Python distribution the binary extension was built against, and on the operating system. Structure of Python package foo foo [Python module] \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 foo_cli [CLI] \u2502 \u2514\u2500\u2500 __main__.py \u251c\u2500\u2500 foo_clisub [CLI] \u2502 \u2514\u2500\u2500 __main__.py \u251c\u2500\u2500 foo_cpp.cpython-39.darwin.so \u251c\u2500\u2500 foo_cpp [C++ binary extension module] \u2502 \u251c\u2500\u2500 foo_cpp.cpp \u2502 \u2514\u2500\u2500 foo_cpp.md \u251c\u2500\u2500 foo_f90.cpython-39.darwin.so \u251c\u2500\u2500 foo_f90 [Modern Fortran binary extension module] \u2502 \u251c\u2500\u2500 foo_f90.f90 \u2502 \u2514\u2500\u2500 foo_f90.md \u2514\u2500\u2500 foo_py [Python module] \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 bar.cpython-39.darwin.so \u2514\u2500\u2500 bar [C++ binary extension module] \u251c\u2500\u2500 bar.cpp \u2514\u2500\u2500 bar.md You can build a single binary extension by specifiyng its path: path/to/FOO > wip build foo_py/bar or build all C++/Fortran binary extensions using wip build --cpp|--f90 .","title":"Add components"},{"location":"user-guide/#documentation","text":"For small projects, we recommend writing down the documentation in README.md . Larger projects with submodules or CLIs are more conveniently documented with mkdocs , using the Markdown format, or sphinx using the restructuredText . When creating a new project, wip asks for a documentation format. If you choose none, you can always add the necessary documentation templates running wip docs [--md|--rst] . Tip Learn documenting your project with mkdocs [here] (https://realpython.com/python-project-documentation-with-mkdocs/).","title":"Documentation"},{"location":"user-guide/#version-management","text":"Wip relies on bump2version for version management. Newly created project have a bumpversion.cfg file. The bumpversion command can directly be used, e.g.: bump[2]version major|minor|patch|release . There is also a wip subcommand wip bump that wraps the bumpversion command and lists information about the previous and the new version: path/to/FOO > bumpversion patch path/to/FOO > wip bump patch [[Running `bump2version patch`` in directory 'foo' ... ]] (done Running `bump2version patch`) foo v0.0.1-dev -> v0.0.2-dev path/to/FOO > wip bump release [[Running `bump2version release`` in directory 'foo' ... ]] (done Running `bump2version release`) foo v0.0.2-dev -> v0.0.2 > wip bump minor [[Running `bump2version minor`` in directory 'foo' ... ]] (done Running `bump2version minor`) foo v0.0.2 -> v0.1.0-dev","title":"Version management"},{"location":"user-guide/#publishing-on-pypi","text":"When your code is published on PyPI users can effortlessly install it with pip install your-package . Dependencies are automatically installed as well. Wip relies on poetry for publishing to PyPI . To be able to publish on PyPI, you must Create an account on PyPI . Log in on your account, and go to account settings . Scroll down and hit Add API token . Choose a token name, e.g. poetry-publishing-on-pypi , and select a scope, e.g. Entire account (all projects) to use the token for publishing all your projects. Hit Add token to generate a new token, and copy the token. Finally, add your API token to Poetry with this command poetry config pypi-token.pypi your-api-token (paste the copied token for your-api-token ). Now you can publish your code as below: (wiptools-py3.9) ~/workspace/wiptools > poetry publish --build Building wiptools (1.2.0-dev) - Building sdist - Built wiptools-1.2.0.dev0.tar.gz - Building wheel - Built wiptools-1.2.0.dev0-py3-none-any.whl Publishing wiptools (1.2.0-dev) to PyPI - Uploading wiptools-1.2.0.dev0-py3-none-any.whl 100% - Uploading wiptools-1.2.0.dev0.tar.gz 100% Note You can publish a version of your code only once to PyPI. If you want to publish an update, you must bump2version your code first.","title":"Publishing on PyPI"}]}